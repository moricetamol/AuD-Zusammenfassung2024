\documentclass[
../../AuD-Zusammenfassung.tex,
]
{subfiles}

\externaldocument[ext:]{../../AuD-Zusammenfassung}
% Set Graphics Path, so pictures load correctly
\graphicspath{{../../}}

\begin{document}
\section{Grundlegende Datenstrukturen}
\subsection{Stacks}
Stacks operieren unter dem "First in - Last out" (FILO) Prinzip. Ähnlich zu einem Kartendeck, wo die unterste (Erste Karte) die ist, die als letztes gezogen wird. \\
Stacks werden normalerweise mit den folgenden Funktionen erstellt:
\begin{itemize}
    \item \texttt{new{n}}: Erstellt einen neuen Stack.
    \item \texttt{isEmpty}: gibt an ob der Stack leer ist.
    \item \texttt{pop}: gibt das oberste Element des Stacks zurück und enfernt es vom Stack.
    \item \texttt{push(k)}: Fügt \texttt{k} auf den Stack hinzu
\end{itemize}
Eine mögliche Implementation auf Grundlage eines Arrays wäre:
\lstinputlisting[language=Java]{Code/Stack.java}

Push und Pop schmeißen Fehlermeldung wenn Stack leer bzw. voll ist. Oft als Stack underflow und Stack overflow benannt. Hier wär es automatisch IndexOutOfBounds.\\ Oft werden Stacks auch mit variabler Größer implementiert. Dies kann über verschiedene Wege passieren, zum Beispiel Kopieren des arrays in einen größeren Array oder implementation über mehrere Arrays (z.B. über Linked List). Häufig wird das erstere so implementiert, dass der Array in einen Array mit doppelter Größe kopiert wird.

\newpage
\subsection{Queues}
Queues werden normalerweise mit den folgenden Funktionen erstellt:
\begin{itemize}
    \item \texttt{new{n}}: Erstellt einen neuen Queue.
    \item \texttt{isEmpty}: gibt an ob der Queue leer ist.
    \item \texttt{enqueue(k)}: Fügt \texttt{k} auf den Queue hinzu
    \item \texttt{dequeue}: gibt das erste Element des Queues zurück und entfernt es vom Queue.
\end{itemize}
Hier ist die Implementation für Queues wie folgt:

\lstinputlisting[language=Java]{Code/Queue.java}
\newpage
\subsection{Linked List}
Eine einfache Linked List besteht aus mehreren Elementen, die jeweils immer einen Wert und eine Referenz auf das nächste Element in der Liste haben. Eine einfache Linked List kann wie folgt implementiert werden:

\lstinputlisting[language=Java]{Code/LinkedElement.java}
\lstinputlisting[language=Java]{Code/LinkedList.java}


\newpage
\subsection{Binary Search Tree}
\lstinputlisting[language=Java]{Code/BSTNode.java}
\lstinputlisting[language=Java, lastline = 27]{Code/BSTree.java}
\newpage
\lstinputlisting[language=Java, firstline = 29, lastline = 48]{Code/BSTree.java}
\newpage
\lstinputlisting[language=Java, firstline = 50, lastline = 62]{Code/BSTree.java}
\lstinputlisting[language=Java, firstline = 63, lastline = 89]{Code/BSTree.java}
\lstinputlisting[language=Java, firstline = 90]{Code/BSTree.java}

\newpage
\subsection{Red-Black Tree}
\lstinputlisting[language=Java]{Code/RBNode.java}
\lstinputlisting[language=Java, lastline = 42]{Code/RBTree.java}
\lstinputlisting[language=Java, firstline = 43, lastline = 82, firstnumber = 43]{Code/RBTree.java}
\lstinputlisting[language=Java, firstline = 83, lastline = 119, firstnumber = 83]{Code/RBTree.java}
\lstinputlisting[language=Java, firstline = 121, lastline = 171, firstnumber = 121]{Code/RBTree.java}
\lstinputlisting[language=Java, firstline = 173, lastline = 278, firstnumber = 173]{Code/RBTree.java}
\lstinputlisting[language=Java, firstline = 280, firstnumber = 280]{Code/RBTree.java}

\end{document}