\documentclass[ngerman,
color=3b,
% dark_mode, 
load_common, % Loads a list of commonly used Packages
boxarc,
main,
% manual_term,
% solution=true,
tikz,
border=3mm
]{article}



\usepackage{lmodern}

\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[table,xcdraw,svgnames]{xcolor}
\usepackage[]{amsmath,amsfonts,amsthm,amssymb} %Math & symbols
\usepackage[]{booktabs}

\usepackage[protrusion=true,expansion=true]{microtype}
%-----------------------------------
% Algorithms
%-----------------------------------
\usepackage[
    linesnumbered,
    lined,
    %boxed,
    commentsnumbered,
    ]{algorithm2e}%Algortihms
    
\SetAlgoNlRelativeSize{-1}

\usepackage{algpseudocode}
\usepackage{algorithmicx}

\SetKw{KwContinue}{\color{blue}continue}
\SetKw{KwBreak}{\color{red}break}
\SetKw{KwDownTo}{down to}
\SetKw{KwAnd}{\color{teal}and}
\SetKw{KwOr}{\color{teal}or}
\SetKw{KwError}{\color{red}error}
\SetKwProg{Fn}{\color{MediumSeaGreen}Function}{:}{}
\SetKwProg{Cl}{\color{MediumSeaGreen}Class}{:}{}

%-----------------------------------
% Trees, Skip-Lists etc.
%-----------------------------------
\usepackage{tikz}
\usepackage{tkz-graph}
\usetikzlibrary{trees}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}
\usetikzlibrary{chains}

%-------------------------------------
% Captions
%-------------------------------------
\usepackage[hang, small,labelfont=bf,up,textfont=it,up,labelformat=empty]{caption}
% \captionsetup[figure]{name=Skip-List}

\usepackage{caption}
\usepackage[]{sectsty}
\usepackage{titlesec}
%------------------------
% Footer and Header
%------------------------
\usepackage[]{fancyhdr} % For footers and header
\pagestyle{fancy}
\usepackage[]{lastpage} %For page reference: Page x out of y

\lhead{} % Left Header
\chead{} % Centre Header
\rhead{} % Right Header

\lfoot{} % Left Footer
\cfoot{} % Centre Footer
\rfoot{\footnotesize Seite \thepage\ von \pageref{LastPage}} % Right Footer - Page Reference

\renewcommand{\headrulewidth}{0.0pt} % Sets size of header rule - here its not visible 
\renewcommand{\footrulewidth}{0.4pt} % Sets size of footer rule
%----------------------------------------------
% Title
%----------------------------------------------
\usepackage{titling}
\newcommand{\HorRule}{\color{Black} \rule{\linewidth}{2pt}}
\newcommand{\TitleRule}{\color{Green} \rule{\linewidth}{15pt} \vspace{-90pt}\linebreak \HorRule \linebreak}
%\newcommand{\TitleRule}{\color{Green} \titlerule[15pt] \color{White} \titlerule[7pt] \color{Black} \titlerule[2pt]}
\newcommand{\SectionHorRule}{\color{Black} \rule{\linewidth}{1pt}}

\pretitle{\vspace{-80pt} \fontsize{30}{50} \usefont{OT1}{phv}{b}{n} \TitleRule \color{Black}} % Horizontal rule before the title
	
	\title{AuD - Zusammenfassung} % The title
	
	\posttitle{\vskip 0.5em} % Whitespace under the title

\preauthor{\begin{flushleft}\large \lineskip 0.5em \fontsize{15}{0} \usefont{T1}{phv}{b}{} \color{Black}} % Author font configuration
	
	\author{Moritz Gerhardt } % Name
	
	\postauthor{% Anything you might want to add
		\par\end{flushleft}} % Horizontal rule after the title

\date{} % Add date or leave empty to not show any date !!!\today

%-----------------------------
% Section Style
%-----------------------------

\newcommand{\SectionFont}{\LARGE\bfseries}
\titleformat{\section} % Type of heading to format
%[] % Shape
{\color{Green} \titlerule[15pt] \color{White} \titlerule[7pt] \color{Black} \titlerule[2pt] \SectionFont} % Format
{\thesection} % Label
{1em} % Seperator
{\SectionFont} % Before-Code
[{\titlerule[2pt]}] % After-Code

\newcommand{\SubSectionFont}{\large\bfseries}
\titleformat{\subsection} % Type of heading to format
%[] % Shape
{\SubSectionFont} % Format
{\thesubsection} % Label
{1em} % Seperator
{\SubSectionFont} % Before-Code
[{\titlerule[1pt]}] % After-Code

\renewcommand{\thesection}{Sektion \space \arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}

\usepackage{parskip} % Removes the indentation of the first line of new section

\begin{document}

\thispagestyle{fancy}
\maketitle

\tableofcontents

\newpage

\section{Was ist ein Algorithmus?}
Ein Algorithmus beschreibt eine Handlungsvorschrift zur Umwandlung von Eingaben in eine Ausgabe.\\
Dabei sollte ein Algorithmus im allgemeinen folgende Vorraussetzungen erfüllen:
\begin{enumerate}
    \item Bestimmt:
    \begin{itemize}
        \item Determiniert: Bei gleicher Eingabe liefert der Algortihmus gleiche Ausgabe. \\$\implies$ Ausgabe nur von Eingabe abhängig, keine äußeren Faktoren.
        \item Determinismus: Bei gleicher Eingabe läuft der Algorithmus immer gleich durch die Eingabe. \\$\implies$ Gleiche Schritte, Gleiche Zwischenstände.
    \end{itemize}
    \item Berechenbar:
    \begin{itemize}
        \item Finit: Der Algorithmus ist als endlich definiert. (Theoretisch)
        \item Terminierbar: Der Algorithmus stoppt in endlicher Zeit. (Praktisch)
        \item Effektiv: Der Algorithmus ist auf Maschine ausführbar.
    \end{itemize}
    \item Andwendbar:
    \begin{itemize}
        \item Allgemein: Der Algorithmus ist für alle Eingaben einer Klasse anwendbar, nicht nur für speziellen Fall.
        \item Korrekt: Wenn der Algorithmus ohne Fehler terminiert, ist die Ausgabe korrekt.
    \end{itemize}
\end{enumerate}

\section[]{Sortieren}
\subsection{Sortierproblem}
Sortieralgorithmen sind die wohl am häufigsten verwendeten Algorithmen. Hierbei wird als Eingabe eine Folge von Objekten gegeben, die nach einer bestimmten Eigenschaft sortiert werden. Der Algorithmus soll die Eingabe in der richtigen Reihenfolge (nach einer bestimmten Eigenschaft) zur Ausgabe umwandeln. Es wird hierbei meist von einer total geordneten Menge ausgegangen. (Alle Elemente sind miteinander vergleichbar). \\
Eine Totale Ordnung wie folgt definiert:
\begin{center}
    Eine Relation $\leq$ auf $M$ ist eine totale Ordnung, wenn:
    \begin{itemize}
        \item Reflexiv: $\forall x \in M: x \leq x$ \\
        (x steht in Relation zu x)
        \item Transitiv: $\forall x,y,z \in M: x \leq y \wedge y \leq z \implies x \leq z$ \\
        (Wenn x in Relation zu y steht und y in Relation zu z steht, so folgt, dass x in Relation zu z steht)
        \item Antisymmetrisch: $\forall x,y \in M: x \leq y \wedge y \leq x \implies x = y$ \\
        (Wenn x in Relation zu y steht und y in Relation zu x steht, so folgt, dass x = y)
        \item Totalität: $\forall x,y \in M: x \leq y \vee y \leq x$ \\
        (Alle Elemente müssen in einer Relation zueinander stehen)
    \end{itemize}
\end{center}

\newpage
\subsection{Insertion Sort}
\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{inso}{insertion\_sort}

    \Fn{\inso{A}} {
        \For{i = 1 \KwTo A.length - 1}{
            key = A[i] \Comment{Element zum Sortieren}\;
            j = i - 1 \Comment{Einfügepunkt wird von hinten gesucht}\;
            \While{j >= 0 \KwAnd A[j] > key}{
                A[j + 1] = A[j] \Comment{Elemente nach Rechts verschieben}\;
                j = j - 1\;
            }
            A[j + 1] = key \Comment{Element wird in den Einfügepunkt geschoben}\;
        }
    }
\end{algorithm}
Prinzip: Die Eingabe wird von links nach rechts durchlaufen. Dafür wird für jedes Element 

\newpage
\subsection[]{Merge Sort}

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{mS}{mergeSort}

    \Fn{\mS{A, left, right}} {
        \If{left < right}{
            \Comment{Wenn Bereich ist nicht leer}
            mid = floor((left + right) / 2) \Comment{Nach unten gerundet}\;
            mergeSort(A, left, mid) \Comment{Sortiert von left zu mid}\;
            mergeSort(A,mid + 1, right) \Comment{Sortiert von mid + 1 zu right}\;
            merge{A, left, mid, right} \Comment{Fügt Hälften zusammen}
        }
    }
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{merge}{merge}

    \Fn{\merge{A, left, mid, right}} {
        B = new Array[right - left + 1] \Comment{Temp array}\;
        p = left\;
        q = mid + 1\;
        \Comment{Array A wird mithilfe von zwei Pointern durchgegangen, von links und von mid + 1}\;

        \For{i = 0 \KwTo right - left}{
            \Comment{Läuft für jedes Element im Zielbereich}\;
            \If{q > right \KwOr (p =< mid \KwAnd A[p] =< A[q])}{
                \Comment{Wenn q > right, dann ist der rechte Teil durchlaufen. Wenn p =< mid ist, so ist der linke Teil noch nicht durchlaufen. Wenn das linke Element =< dem rechten ist, dann wird das Element dem temp array B hinzugefügt.}\;
                B[i] = A[p]\;
                p = p + 1\;
            }
            \Else{
                \Comment{Wenn oben nicht zutrifft:}\;
                B[i] = A[q]\;
                q = q + 1\;
            }
        }
        \For{i = 0 \KwTo right - left}{
            \Comment{Läuft wieder für jedes Element im Zielbereich}\;
            \Comment{Kopiert den jetzt sortierten temp array B zurück in den eigentlichen Array an der richtigen Stelle}\;
            A[i + left] = B[i] \Comment{i + left, damit nicht am Anfang sondern an dem richtigen Teilbereich eingefügt wird.}\;
        }
    }
\end{algorithm}

\newpage
\subsection{Quicksort}
\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{qs}{quicksort}

    \Fn{\qs{A, left right }}{
        \If{left < right}{
            q = partition(A, left, right)\;
            quicksort(A, left, q)\;
            quicksort(A, q + 1, right)\;
        }
    }
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{parti}{partition}

    \Fn{\parti{A, left, right}}{
        pivot = A[left]\;
        p = left - 1\;
        q = right + 1\;
        \While{p < q}{
            \While{A[p] < pivot}{
                p = p + 1\;
            }
            \While{A[q] > pivot}{
                q = q - 1\;
            }
            \If{p < q}{
                    temp = A[q]\;
                    A[q] = A[p]\;
                    A[p] = temp\;
                }
        }
        \KwRet{q}
    }
\end{algorithm}

\newpage
\subsection{Radix Sort}
\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{radSo}{radixSort}

    keys = digits d in range [0, D-1]\Comment{possible digits}\;
    B = new Array[0]\Comment{Buckets, initially empty}\;

    \Fn{\radSo{A}}{
        \For{i = 0 \KwTo d - 1}{ \Comment{From least to most significant}
            \For{j = 0 \KwTo n - 1}{
                putBucket(A, B, i, j)\;
            }
            a = 0\;
            \For{k = 0 \KwTo D - 1}{
                \For{b = 0 \KwTo B[k].size - 1}{
                    A[a] = B[k][b] \Comment{Read bucket in order}\;
                    a = a + 1\;
                }
                B[k].size = 0 \Comment{Clear Bucket}\;
            }
        }
        \KwRet{A}
    }
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{puBu}{putBucket}

    \Fn{\puBu{A, B, i, j}}{
        z = A[j].digit[i]\Comment{i-th digit of A[j]}\;
        b = B[z].size\Comment{Size corresponds to next free spot}\;
        B[z][b] = A[j]\;
        B[z].size = B[z].size + 1\;
    }
\end{algorithm}

\newpage
\section{Grundlegende Datenstrukturen}
\subsection{Stacks}
Stacks operieren unter dem "First in - Last out" (FILO) Prinzip. Ähnlich zu einem Kartendeck, wo die unterste (Erste Karte) die ist, die als letztes gezogen wird. \\
Stacks werden normalerweise mit den folgenden Funktionen erstellt:
\begin{itemize}
    \item \texttt{new}: Erstellt einen neuen Stack.
    \item \texttt{isEmpty}: gibt an ob der Stack leer ist.
    \item \texttt{pop}: gibt das oberste Element des Stacks zurück und enfernt es vom Stack.
    \item \texttt{push(k)}: Fügt \texttt{k} auf den Stack hinzu
\end{itemize}
Eine mögliche Implementation auf Grundlage eines Arrays wäre:
\begin{algorithm}
    \SetKwFunction{new}{new}
    \SetKwFunction{isEm}{isEmpty}
    \SetKwFunction{pop}{pop}
    \SetKwFunction{push}{push}
    \DontPrintSemicolon

    \Cl{\texttt{Stack}}{

        arr = null\;
        top = -1\;
        \Fn{\new{n}}{
            arr = new Array[n]\;
            \KwRet{\texttt{this}}
        }
        \Fn{\isEm}{
            \KwRet{top == -1}
        }
        \Fn{\pop}{
            \KwRet{arr[top--]}
        }
        \Fn{\push{k}}{
            arr[++top] = k\;
        }
    }
\end{algorithm}
Push und Pop schmeißen Fehlermeldung wenn Stack leer bzw. voll ist. Oft als Stack underflow und Stack overflow benannt. Hier wär es automatisch IndexOutOfBounds.\\ Oft werden Stacks auch mit variabler Größer implementiert. Dies kann über verschiedene Wege passieren, zum Beispiel Kopieren des arrays in einen größeren Array oder implementation über mehrere Arrays (z.B. über Linked List). Häufig wird das erstere so implementiert, dass der Array in einen Array mit doppelter Größer kopiert wird.

\newpage
\subsection{Linked List}
Eine einfache Linked List besteht aus mehreren Elementen, die jeweils immer einen Wert und eine Referenz auf das nächste Element in der Liste haben. Eine einfache Linked List kann wie folgt implementiert werden:
\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{new}{new}
    \SetKwFunction{ins}{insert}
    \SetKwFunction{search}{search}
    \SetKwFunction{del}{delete}

    \Cl{\texttt{LinkedElement}}{
    key = null\;
    next = null\;

    \Fn{\new{k}}{
        key = k\;
        \KwRet{\texttt{this}}
    }
    }
    \;
    \Cl{\texttt{LinkedList}}{
        head = null\;

        \Fn{\ins{k}}{
            elem = new(k)\;
            \If {head == null}{
                head = elem\;
            }
            \Else{
                elem.next = head\;
                head = elem\;
            }
        }
        \Fn{\del{k}}{
            prev = null\;
            current = head\;
            \While{current != null \KwAnd current.key != k}{
                prev = current\;
                current = current.next\;
            }
            \If{current == null}{
                \KwError{Element not found}
            }
            \If{prev != null}{
                prev.next = current.next\;
            }
            \Else{
                head = current.next\;
            }
        }
        \Fn{\search{k}}{
            current = head\;
            \While{current != null \KwAnd current.key != k}{
                current = current.next\;
            }
            \KwRet{current}
        }
    }
\end{algorithm}
\end{document}